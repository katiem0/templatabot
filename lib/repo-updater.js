/**
 * Repository Updater
 * 
 * This module handles propagating changes from template repositories to repositories
 * that were created from them, and creating pull requests with those changes.
 */

// Branch name to use for template updates
const UPDATE_BRANCH_PREFIX = 'template-update-';

/**
 * The RepoUpdater handles propagating changes from template repos to derived repos
 */
class RepoUpdater {
  /**
   * Propagate changes from a template repository to a repository created from it
   * 
   * @param {import('probot').Context} context - Probot context
   * @param {object} templateRepo - The template repository object
   * @param {object} targetRepo - The repository object that uses the template
   */
  async propagateChanges(context, templateRepo, targetRepo) {
    const { octokit } = context;
    const [targetOwner, targetRepoName] = targetRepo.full_name.split('/');
    const timestamp = new Date().toISOString().replace(/[-:]/g, '').replace(/\..+/, '');
    const branchName = `${UPDATE_BRANCH_PREFIX}${timestamp}`;
    
    try {
      context.log.info(`Propagating changes from ${templateRepo.full_name} to ${targetRepo.full_name}`);
      
      // Get the default branch of the target repository
      const targetRepoDetails = await octokit.rest.repos.get({
        owner: targetOwner,
        repo: targetRepoName,
      });
      
      const baseBranch = targetRepoDetails.data.default_branch;
      
      // Get the reference to the default branch
      const ref = await octokit.rest.git.getRef({
        owner: targetOwner,
        repo: targetRepoName,
        ref: `heads/${baseBranch}`,
      });
      
      const baseSha = ref.data.object.sha;
      
      // Create a new branch for the template updates
      await octokit.rest.git.createRef({
        owner: targetOwner,
        repo: targetRepoName,
        ref: `refs/heads/${branchName}`,
        sha: baseSha,
      });
      
      context.log.info(`Created branch ${branchName} in ${targetRepo.full_name}`);
      
      // Get changes from template repo (most recent commit)
      const templateOwner = templateRepo.owner.login;
      const templateRepoName = templateRepo.name;
      
      const templateCommits = await octokit.rest.repos.listCommits({
        owner: templateOwner,
        repo: templateRepoName,
        per_page: 1,
      });
      
      const latestCommit = templateCommits.data[0];
      const commitMessage = latestCommit.commit.message;
      
      // Get template files that changed
      const changedFiles = await this.getChangedFiles(
        octokit,
        templateOwner, 
        templateRepoName,
        latestCommit.sha
      );
      
      // Apply the changes to the target repository
      await this.applyChangesToRepo(
        octokit,
        templateOwner,
        templateRepoName,
        targetOwner,
        targetRepoName,
        branchName,
        changedFiles
      );
      
      // Create a pull request with the changes
      const prTitle = `Template Update: ${commitMessage.split('\n')[0]}`;
      const prBody = `This PR updates this repository with the latest changes from the template repository (${templateRepo.full_name}).

## Changes from template
${commitMessage}

---
_This PR was automatically generated by TemplateBot_`;

      const pr = await octokit.rest.pulls.create({
        owner: targetOwner,
        repo: targetRepoName,
        title: prTitle,
        body: prBody,
        head: branchName,
        base: baseBranch,
      });
      
      context.log.info(`Created PR #${pr.data.number} in ${targetRepo.full_name}`);
      
      return pr.data;
    } catch (error) {
      context.log.error(`Error propagating changes to ${targetRepo.full_name}:`, error);
      throw error;
    }
  }
  
  /**
   * Get files that changed in the most recent commit to the template
   * 
   * @param {import('@octokit/rest').Octokit} octokit - Octokit instance
   * @param {string} owner - Template repo owner
   * @param {string} repo - Template repo name
   * @param {string} commitSha - Commit SHA to analyze
   * @returns {Promise<Array<object>>} - List of changed files
   */
  async getChangedFiles(octokit, owner, repo, commitSha) {
    const commit = await octokit.rest.repos.getCommit({
      owner,
      repo,
      ref: commitSha,
    });
    
    return commit.data.files;
  }
  
  /**
   * Apply changes from template repo to target repo
   * 
   * @param {import('@octokit/rest').Octokit} octokit - Octokit instance
   * @param {string} templateOwner - Template repo owner
   * @param {string} templateRepo - Template repo name
   * @param {string} targetOwner - Target repo owner
   * @param {string} targetRepo - Target repo name
   * @param {string} branch - Branch name to apply changes to
   * @param {Array<object>} changedFiles - List of changed files
   */
  async applyChangesToRepo(
    octokit,
    templateOwner,
    templateRepo,
    targetOwner,
    targetRepo,
    branch,
    changedFiles
  ) {
    // Process each changed file
    for (const file of changedFiles) {
      try {
        // Skip deleted files for now
        if (file.status === 'removed') {
          continue;
        }
        
        // Get the file content from the template repository
        const fileContent = await octokit.rest.repos.getContent({
          owner: templateOwner,
          repo: templateRepo,
          path: file.filename,
        });
        
        const content = Buffer.from(fileContent.data.content, 'base64').toString();
        
        // Check if the file exists in the target repository
        try {
          // Try to get the file from the target repo
          await octokit.rest.repos.getContent({
            owner: targetOwner,
            repo: targetRepo,
            path: file.filename,
          });
          
          // If the file exists, update it
          await octokit.rest.repos.createOrUpdateFileContents({
            owner: targetOwner,
            repo: targetRepo,
            path: file.filename,
            message: `Update ${file.filename} from template`,
            content: Buffer.from(content).toString('base64'),
            branch,
          });
        } catch (error) {
          // File doesn't exist, create it
          if (error.status === 404) {
            await octokit.rest.repos.createOrUpdateFileContents({
              owner: targetOwner,
              repo: targetRepo,
              path: file.filename,
              message: `Add ${file.filename} from template`,
              content: Buffer.from(content).toString('base64'),
              branch,
            });
          } else {
            throw error;
          }
        }
      } catch (error) {
        console.error(`Error applying changes for file ${file.filename}:`, error);
        // Continue with the next file
      }
    }
  }
}

// Export a singleton instance of the RepoUpdater
exports.repoUpdater = new RepoUpdater();